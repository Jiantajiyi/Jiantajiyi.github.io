<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spanning Tree 增强]]></title>
    <url>%2F2018%2F12%2F03%2FSpanning-Tree-%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 Spanning Tree 增强portfast 端口加速 针对交换机的access接口，连接的是终端用户例如router、PC、server 等等，这些不需要运行生成树的接口。 接口默认进入listening状态，等待 30s才能进入转发状态. 位置：接入层交换机的access 接口 做完之后节约时间：30s 配置sw1(config)#int range ethernet 2/0-1sw1(config-if-range)#spanning-tree portfast提示： %Warning: portfast should only be enabled on ports connected to a single host. Connecting hubs, concentrators, switches, bridges, etc... to this interface when portfast is enabled, can cause temporary bridging loops. Use with CAUTION %Portfast will be configured in 2 interfaces due to the range command but will only have effect when the interfaces are in a non-trunking mode. 注意：不同型号的交换机命令稍有不同 全局启用：sw1(config)#spanning-tree portfast edge default 在某些接口上关闭portfastsw1(config)#int e0/1sw1(config-if)#spanning-tree portfast disable 在trunk接口启用portfast（默认情况下，接口一旦收到BPDU，portfast 失效）sw1(config)#int e0/1sw1(config-if)#spanning-tree portfast edge trunk uplinkfast 上行链路加速 若上行链路发送故障，阻塞端口进入listening 状态，默认等待30s进 入forwarding 位置：所有的接入层交换机上 节约时间30s 配置首先将sw1，sw2，sw3上的e0/0-3，e1/0-1关闭，然后打开sw1上的e0/0，e0/2，sw2上的e0/0，e1/0，sw3上的e0/2，e1/0则sw1为根网桥，sw1接口全为制定端口，sw2上e0/0为根端口，e1/0为指定端口，sw3上e0/2为根端口，e1/0为阻塞端口结果 sw1 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et0/0 Desg FWD 100 128.1 Shr Et0/2 Desg FWD 100 128.3 Shr sw2 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et0/0 Root FWD 100 128.1 Shr Et1/0 Desg FWD 100 128.33 Shr sw3 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et0/2 Root FWD 100 128.3 Shr Et1/0 Altn BLK 100 128.33 Shr 打开sw3的debugsw3#debug spanning-tree events Spanning Tree event debugging is on 关闭sw3上e0/2，即down掉sw3到sw1的上行链路sw3(config)#int e0/2sw3(config-if)#shu 结果：可以看到e1/0端口立即进入listening状态，随即15秒后进入learning，再15秒进入forwarding，即e1/0阻塞端口成为根端口转发数据，整个过程用了30s sw3(config-if)# *Nov 24 22:16:35.014: STP: VLAN0001 new root port Et1/0, cost 200 *Nov 24 22:16:35.014: STP: VLAN0001 Et1/0 -&gt; listening *Nov 24 22:16:35.014: STP[1]: Generating TC trap for port Ethernet0/2 sw3(config-if)# *Nov 24 22:16:37.018: %LINK-5-CHANGED: Interface Ethernet0/2, changed state to administratively down sw3(config-if)# *Nov 24 22:16:37.018: STP: VLAN0001 sent Topology Change Notice on Et1/0 *Nov 24 22:16:38.026: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/2, changed state to down sw3(config-if)# *Nov 24 22:16:50.018: STP: VLAN0001 Et1/0 -&gt; learning sw3(config-if)# *Nov 24 22:17:05.018: STP[1]: Generating TC trap for port Ethernet1/0 *Nov 24 22:17:05.018: STP: VLAN0001 sent Topology Change Notice on Et1/0 *Nov 24 22:17:05.018: STP: VLAN0001 Et1/0 -&gt; forwarding 打开e0/2端口然后做uplinkfastsw3(config)#spanning-tree uplinkfast 变化：意思他要离根网桥远一点，一般最底层的接入层交换机才做 显示 Uplinkfast enabled 优先级变为 priority 49152 32768+4*4096=49152 cost值增加3000 再次关闭e0/2端口结果 *Nov 24 23:04:45.790: %SPANTREE_FAST-7-PORT_FWD_UPLINK: VLAN0001 Ethernet1/0 moved to Forwarding (UplinkFast). 表示e1/0口直接成为根端口转发数据 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et1/0 Root FWD 3100 128.33 Shr 全局模式Spanning tree uplinkfast rata-limit 100 （单位数据包每秒）开始sw3上的e1/0接口是阻塞的，通过e0/2接口学习mac地址转发数据，若e0/2 down掉，则e1/0成为根端口转发数据，此时sw2上则需要学习sw3上大量的mac地址，为了做好切换过程，做了全局uplinkfast后，在e0/2未down之前会通过e1/0阻塞端口向上发送伪包，为了让sw2学习sw3上的mac地址，则若e0/2 down掉，e1/0成为根端口后可以直接转发数据。 backbonefast 骨干加速 若骨干链路发生故障，下行链路经过50s进入forwarding状态； 启用backbonefast特性，若收到次级BPDU，通过根端口向根网桥发送 RIQ查询（询问优质根是否正常），若正常由根网桥返回RIQ应答，描 述根正常，则blocking接口进入listening状态，经过30s进入forwarding. 部署位置：所有交换机 节约时间：20s 启用backbonefast特性重新打开sw3的e0/2接口，则e0/2重新成为根端口，e1/0为阻塞端口若down掉sw1连接sw2的骨干链路（关闭sw2的e0/0），则sw3的e1/0接口成为指定端口，sw2的e1/0成为根端口，这个过程中sw3的e1/0接口成为指定端口需要经过50s sw3(config-if)# *Nov 24 23:35:02.798: STP: VLAN0001 heard root 28673-0203.e900.0200 on Et1/0 sw3(config-if)# *Nov 24 23:35:03.966: STP: VLAN0001 Et1/0 -&gt; listening *Nov 24 23:35:04.798: STP: VLAN0001 heard root 28673-0203.e900.0200 on Et1/0 *Nov 24 23:35:04.798: STP: VLAN0001 Topology Change rcvd on Et1/0 *Nov 24 23:35:04.798: STP: VLAN0001 sent Topology Change Notice on Et0/2 sw3(config-if)# *Nov 24 23:35:18.974: STP: VLAN0001 Et1/0 -&gt; learning sw3(config-if)# *Nov 24 23:35:33.974: STP[1]: Generating TC trap for port Ethernet1/0 *Nov 24 23:35:33.974: STP: VLAN0001 sent Topology Change Notice on Et0/2 *Nov 24 23:35:33.974: STP: VLAN0001 Et1/0 -&gt; forwarding *Nov 24 23:35:33.974: stp_state_change_completed: Et1/0. new state = FWD 详解：骨干链路断开后，sw2不能收到sw1的BPDU，所以sw2就以为自己是根网桥，则sw2会向sw3发送BPDU（此BPDU与之前向sw3发送的不一样，之前发送的rid是sw1，bid是sw2自己，现在发送的rid和bid都是sw2自己），此时sw3通过sw1收到的BPDU，rid要优于sw2发送的（称sw2的为次级BPDU），故sw3会忽略sw2发送的BPDU，但sw3的阻塞端口e1/0会一直监听sw2发来的BPDU，之前一直收到的是来自于根网桥的BPDU，现在不能收到来自于根网桥的BPDU了，超时时间20s，则sw3的e1/0端口会进入listening状态，告诉sw2根网桥还活着（向sw2发送优质BPDU），直到进入forwarding，整个过程需要50s backbonefast建议在所有交换机都做骨干链路断开之后，sw2会向sw3发送次级BPDU，sw3会忽略，做了backbonefast后，收到次级BPDU后，sw3会主动向根网桥发送根链路查询请求报文（RLQ request） ，根网桥会回复根链路查询响应报文（RLQ response），sw3知道sw2收不到根网桥发送的BPDU，以为自己是根网桥了，所以sw3的e1/0接口直接进入listening状态，告诉sw2根网桥还活着（向sw2发送优质BPDU），直到进入forwarding，整个过程需要30s，节约了20s。重新打开sw2的e0/0端口配置sw1(config)#spanning-tree backbonefastsw2(config)#spanning-tree backbonefastsw3(config)#spanning-tree backbonefast关闭sw2的e0/0端口结果 sw3(config)# *Nov 25 00:07:22.998: STP: VLAN0001 heard root 28673-0203.e900.0200 on Et1/0 *Nov 25 00:07:22.998: STP: VLAN0001 Et1/0 -&gt; listening 可知sw3的e1/0端口立即进入listening状态。 根端口：root port RP指定端口：DP阻塞端口：NDP]]></content>
      <categories>
        <category>CCNP</category>
      </categories>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复习重点]]></title>
    <url>%2F2018%2F12%2F03%2FC-%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 C++重点 函数重载必须有不同的形参列表 析构函数可以是虚函数 具有纯虚函数的类不能创建类对象 静态数据成员是类的所有对象共享的数据 将一组对象的共同特征抽象出形成类 friend void B::fun(); //B的成员函数fun()说明为A的友元函数 如果一个引用不是用作函数参数或返回值，则在说明该引用时必须进行 初始化 const double pi = 3.141592653589793 ; int operator++(int x); // ++运算符重载 动态联编通过基类指针或引用调用虚函数完成 构造函数访问权限是公有的 基类对象的地址不能赋给派生类 创建对象时 test(2); 表示创建一个对象并赋值2 test[2]; 表示创建两个对象，并且值为默认值 main函数执行完毕之后才执行析构函数，每个对象析构一次 创建对象时，类a被调用一次，执行类a里的函数时，类a又被调用一次 c继承b，c类内对a赋值，创建c类对象时 先调用类b，再调用类a，最后调用c类本身。 在函数模板的参数中，用class修饰的参数称为虚拟类型参数 以面向对象方法构造的系统，其基本单位是对象 对象是类的一个实列 对象将其大部分细节隐藏起来，这种机制称为封装 复杂对象可以由简单对象构成，称为聚合 C++支持编译时的多态性和运行时的多态性 C++中，编译时的多态性是通过重载实现，运行时的多态性通过虚函数实现 三个阶段：分析，设计，实现 若在类的定义体中给出了一个成员函数的完整定义，则该函数属于内联函数 把一个类的定义体和所有成员函数的定义体所构成的程序范围叫做该类的作用域 对类中对象成员的初始化是通过在构造函数中给出的初始化表实现的，也可以通过构造函数中的函数体实现 对类中对象成员和常量成员和引用成员的初始化是通过构造函数给出的初始化表实现的 AB为一个类， AB(AB&amp; x); 为类AB的拷贝构造函数 重载运算符时，该运算符的优先级，结合性，操作符的个数不允许改变，不能创建没有的运算符 单目运算符作为类的成员函数重载时有0个参数，独立函数重载时有1个参数。双目运算符作为类的成员函数重载时有1个参数，独立函数重载时有2个参数。赋值运算符不能被派生类继承 虚基类是为了消除二义性 在每个成员函数中，隐含的第一个参数的参数名为this 隐含的第一个参数类型为 类名* 保证一个公共的基类在派生类中只产生一个基类子对象，则必须都以虚基类的方式直接继承它。 B类继承A类，用B类创建对象后，先析构B类，在析构A类 用户可以重新定义标准库函数，若如此，该函数将失去原有含义 引用调用是 形参是引用，实参是变量 函数调用不可以作为一个函数的形参 成员函数重载是为了使用方便，提高可读性和灵活性 void *为无类型指针，能够指向不论什么数据类型，可以用随意数据类型的指针对void指针赋值 面向对象方法的多态性是指针对一消息，不同的对象可以以适合自身的方式加以响应 OOA：面向对象分析（analysis） OOD：面向对象设计（design） 类中定义的成员默认为private访问属性，结构中定义的成员默认为public访问属性 一个类的静态数据成员所表示属性只是类的属性 静态成员函数只允许操作静态成员变量，不允许操作非静态成员变量 静态数据成员的初始化是在全局区中进行的 类A是类B的友元类，类A的所有成员函数都可以访问类B的所有成员。 一个类的友元不是该类的成员，但与该类的关系密切，所以他没有this指针，也就没有默认操作的对象 a++中的++是作为普通函数重载的运算符，则调用格式可以是operator++(a,1)++a中的++是作为成员函数重载的运算符，则调用格式可以是a.operator++()]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spanning Tree]]></title>
    <url>%2F2018%2F12%2F02%2FSpanning-tree%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 Spanning Tree 生成树目的：交换机之间存在冗余（备份）路径，以及交换机的泛洪机制，导致交换机之间产生 二层交换环路。 造成影响：1.广播风暴（数据在两个或多个交换机之间大量重复传递）2.MAC地址表不稳定 （交换机会将某个主机的mac地址重复删除和学习）3.数据帧的重复拷贝（由于ARP会泛洪和数据的重复传递，导致A主机发送的ARP会被交换机重复发送到B主机） 解决方案：逻辑性阻塞某个接口. 在交换机之间，通过发送比较信息，选择在环路之间应该被阻塞的接口. 生成树类型： 公有生成树：STP（又称为802.1D 标准生成树）RSTP（802.1W 快速生成树）MST（802.1S 多生成树） 私有生成树：PVST（基于VLAN的标准生成树，每一VLAN都有自己的一套生成树）PVRST+（基于VLAN的快速生成树） 发送比较信息BPDU—网桥协议数据单元配置BPDU：config-BPDU拓扑变更BPDU：TCN-BPDU Protocol ID：协议号，代表我是一个BPDU报文 Version：表示是哪一种BPDU（802.1D或者802.1W等） Message Type：表示是配置BPDU还是拓扑变更BPDU Flags：802.1D中描述是拓扑变更BPDU还是拓扑变更BPDU确认，占2Bit。802.1W和802.1S中，用于整个生成树的选举，占6Bit。 Root ID：根标识符 ，在一棵生成树中表示唯一根.使用最优质的BID表示，即根交换机的RID=BID。 Cost Of Path：也称为CoP值，路径开销，描述了本接口到达根的路径开销值之和，数值越小越优10G—–21G——–4100M—–1910M—–100默认根网桥上所有接口的COP值为0，经过不同的链路增加对应的cost Bridge ID ：网桥标识符，用于表示该交换机或网桥在交换网络中的唯一性构成：BID 优先级 + mac地址注意：PVST、PVRSTP+ 的构成 ：BID优先级+VLAN ID+mac地址MST 的构成 ：BID优先级+ instance ID + mac地址 BID优先级：默认值为32768，数值范围0-65535（BID优先级数值必须为4096的倍数， 范围也可称为0-61440）,再使用BID优先级时，数值越小越优. Mac 地址：本交换机上背板地址池中最小的MAC地址，mac地址越小越优 Port ID ：端口标识符，用于表示本交换机上接口的唯一性标识构成： PID优先级+port number PID优先级：默认为128，数值范围0-255（PID优先级必须为16的倍数，所有范围 0-240）,数值越小越优 Port number：端口号，表示了本交换机该接口的唯一性，一般为接口的端口号标 识，数值越小越优. Message age ：消息时间，也称消息的老化时间，实际上等于MAC地址老化时间， 默认300s，即300s不发任何数据就删掉此mac地址，在启用portfast等特性时变为15s Max age ：最大等待时间，默认20s，hello数据包的超时时间以及从blocking进入 listening 状态等待时间 Hellotime ：默认2s，配置BPDU的发送间隔 Forward delay ：转发延时，默认15s ，在生成树中状态切换间隔Listening进入learning进入forwarding 时间隔 交换网络中交换机的角色以及端口状态切换交换机角色：分为根网桥和非根网桥端口角色：根端口、指定端口、非指定端口（阻塞端口）端口状态切换： Blocking ：阻塞状态，不能发送BPDU，接收BPDU，不能发送和接收数据，被动等待 20s进入下一状态 Listening ：监听状态，可以发送和接收BPDU，不能发送和接收数据，进行STP选举， 被动等待一个 forward delay 15s进入下一状态 Learning ：学习状态，可以发送和接收BPDU，不能发送和接收数据，可以学习BPDU 中的源MAC地址（MAC地 址学习状态），被动等待一个forward delay 15s进入下一 状态，生成树的选举在此过程中完成。 Forwarding ：转发状态，可以发送、接收BPDU和数据，mac地址学习和生成树接口 状态切换完成 生成树选举选举顺序：根网桥-&gt;根端口-&gt;指定端口-&gt;非指定端口(阻塞端口)根网桥选举：具有最优BID的交换机为根网桥 根端口：用于接收来自根的BPDU信息，只能存在于非跟网桥之上，并且一个交换机 只能存在一个. 根端口选举1.最小COP值2.发送方最小的BID3.发送方的PID 指定端口：用于发送或转发BPDU信息，存在于每条链路中，一条只能存在一个指定 端口，根网桥的所有接口全为指定端口 指定端口选举1.接口所属交换机上根端口到达根网桥的COP值2.本交换机BID3.本地的PID阻塞端口逻辑上打破接口. 选举详细过程根网桥选举 这里假设sw1 BID优先级最高（bid优先级以此类推），故sw1为根网桥根端口选举 SW1：无根端口 SW2：1.最小cop（接口1和2）相同2.发送方都为根网桥，bid相同3.根网桥接口5的pid小，故选出根端口为接口1 SW3：1.最小cop（接口1和2）相同2.发送方都为根网桥，bid相同3.根网桥接口1的pid小，故选出根端口为接口1 SW4：1.最小cop（接口1和2）相同2.发送方都为根网桥，bid相同3.根网桥接口3的pid小，故选出根端口为接口1 SW5：1.最小cop（接口1和2）相同2.发送方sw3的bid小于sw4的bid，故选出根端口为接口1 SW6：1.最小cop（接口1和2）相同2.发送方sw3的bid小于sw4的bid，故选出根端口为接口1 根端口选举结果如图 指定端口选举 SW1：所有接口都为指定端口 SW2：接口2一定为阻塞端口1.接口3和4与sw2相比， cop相同，接口5与6和sw4相比，cop相同2.本交换机BID优于sw3和sw4，故接口3，4，5，6为指定端口 SW3：sw5和sw6有唯一的根端口，故接口7和8一定为指定端口，接口2，3，4一定为阻塞端口1.接口5和6与sw4相比cop相同2.本交换机BID优于sw4，故接口5和6为指定端口 SW4：接口2，3，4一定为阻塞端口1.接口7与sw5相比，cop小于sw5，故接口7为指定端口接口8与sw6相比，cop小于sw6，故接口8为指定端口 SW5：接口2为阻塞端口 SW6：接口2为阻塞端口 指定端口选举第三条的特殊情况假设sw1和sw2的cop相同，sw2的bid优，但sw2的接口1和2不能同时成为指定端口，否则会出环，所以比第三条接口pid，由于sw2的接口1的pid小于接口2的pid，故接口1成为指定端口生成树拓扑结构变化由发生改变的交换机的根端口向根网桥发送拓扑变更BPDU，根网桥收到后以自己为根重新收敛，之后在向之前发送拓扑变更BPDU的根端口发送拓扑变更BPDU确认 生成树的控制 根网桥的控制设置BID优先级，默认为32768，修改sw2的bid为32768-4096=28672sw2(config)#spanning-tree vlan 1 priority 28672This bridge is the root设置主根和备份根，设置sw1为主根，sw2为备份根sw1(config)#spanning-tree vlan 1 root primarysw2(config)#spanning-tree vlan 1 root secondary主根的优先级变为32768-2*4096=24576Bridge ID Priority 24577 (priority 24576 sys-id-ext 1)备份根的优先级变为32768-4096=28672Bridge ID Priority 28673 (priority 28672 sys-id-ext 1) 控制根端口的位置修改链路cost值：修改sw2的cost为120sw2(config-if)#spanning-tree vlan 1 cost 120修改前Et0/0 Root FWD 100 128.1 ShrEt0/1 Altn BLK 100 128.2 Shr修改后Et0/0 Altn BLK 120 128.1 ShrEt0/1 Root LIS 100 128.2 Shr修改发送方BID：与上述修改根网桥之修改BID优先级方法一致修改发送方PID：修改sw1的e0/2接口pid为192sw1(config-if)#spanning-tree vlan 1 port-priority 192修改之后sw1Et0/2 Desg FWD 100 192.3 Shr修改之前sw3Et0/2 Root FWD 100 128.3 ShrEt0/3 Altn BLK 100 128.4 Shr修改之后sw3Et0/2 Altn BLK 100 128.3 ShrEt0/3 Root LIS 100 128.4 Shr 802.1D生成树优缺点优点：树少、简单、缺点：生成树收敛速度慢（默认共计收敛时间50s），基于计时器收敛、不能进行负 载分担 PVST优缺点优点：简单、支持负载分担缺点：生成树收敛速度慢，生成树数量较多. 解决办法：1.使用spanning tree 的增强特性 portfast、backbonefast 、uplinkfast2.使用RSTP或MST]]></content>
      <categories>
        <category>CCNP</category>
      </categories>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信透明头像]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%BE%AE%E4%BF%A1%E9%80%8F%E6%98%8E%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 先来一张效果图 教程开始素材的准备和PhotoShop软件这里我以滑稽表情为例 用PS打开滑稽表情 按住Shift+Ctrl+N新建图层 抠图 抠图完成后按Ctrl+X 然后删除这个图层 按Ctrl+V粘贴到第二部新建的图层中然后选中这个图层 按Ctrl+T进行缩放 缩放成如图所示的大小 保存为png格式 复制到手机上（复制原文件）在手机微信上更换图像这里需要注意的是 要把图像缩放到合适的大小手动滑稽~…~]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为MIUI添加人脸解锁]]></title>
    <url>%2F2017%2F12%2F02%2F%E4%B8%BAMIUI%E6%B7%BB%E5%8A%A0%E4%BA%BA%E8%84%B8%E8%A7%A3%E9%94%81%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 玩腻了指纹解锁，试试看人脸识别吧，FaceID For MIUI9_MI5解Bootloader锁解Bootloader锁教程:点这里 刷第三方Recovery小米5专用RecoveryBY~XM大佬的rec本人一直用的这个rec 支持OTA增量更新 进入rec法一：开机按电源键+音量键上 直到mi标出现放开电源键法二：系统更新界面-右上角三个小圆点-重启到恢复模式（Recovery） 刷入卡刷包请注意此卡刷包只适用于官方稳定版或开发版FaceID For MIUI9_Mi5.zip密码：6666 重启大功告成不刷第三方rec的方法还是解Bootloader锁解Bootloader锁教程:点这里 下载资源下载软件里边有所有的资源小米五人脸解锁提取+工具.zip密码：6666 安装两个APPRE文件管理器，syslock（用来解system锁） 获取root权限并赋予权限1.开发版直接在安全中心开启root权限2.给这两个APP赋予root权限3.使用syslock解锁system（需要重启） 至此获取了完整的root权限 替换文件1.用《需要替换的app》中的两个apk文件替换 /system/priv-app/settings 和 /system/priv-app/MiuiKeygard 中的两个 App.2.用《需要替换的文件》中的五个文件替换 system/lib64 目录下的五个 so 文件（直接复制进去） Reboot 大功告成！小米五，红米note4.MIX.5s.5sp.部分6.部分红米.5x暂时都可以使用，理论支持miui9所有稳定版，开发板，体验版。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义QQ动态图像的教程]]></title>
    <url>%2F2017%2F11%2F10%2FQQ%E5%8A%A8%E6%80%81%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 自定义QQ动态图像可以先看一下我的QQ头像。点击加我为好友其实很简单，就是一个替换文件的操作。 把要设置的视频【MP4格式，10秒之内，文件尽量不要太大】粘贴到（DCIM）里面的（Camera）文件夹里，切记不要退出。 切换到QQ，点开头像拍摄动态头像，这一点要记住拍完视频不要点完成。 切换到文件管理，你会发现这个文件夹里多了一个视频，你把这个多出来的视频文件名复制一下，并且删除这个视频。 然后找到你刚才剪切粘贴的那个视频，把文件名字替换了，切换QQ点完成就可以了。是不是很简单呢，如果没明白的话，去我的QQ空间有视屏教程。tips：进空间使劲往下拉。 使用Ctrl+D收藏本站 不是不做，时候未到。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
