<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IPSEC-VPN]]></title>
    <url>%2F2018%2F12%2F24%2FIPSEC-VPN%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 IPSEC VPN如何保障数据传递的安全性 私密性：使用对称加密算法和非对称加密算法 完整性：使用hash 散列函数 源认证：数字签名 hmac 不可否认性：数字证书 加密算法 对称加密算法：DES（56bit） 3DES（168bit） AES（256bit） 非对称加密算法：RSA DH ECC RC2/3/4/6 HASH 函数： 认证算法特点：1.不可逆性2.雪崩效应3.不等长输入、等长的输出4.不同的数据产生不同的hash值 MD5（128 bit） SHA（160 bit） 数字签名：将数据使用hash认证算法计算得到hash值，将hash值使用非对称算法中私钥加密。 数字证书：由可信的第三方颁发（CA机构），内容包含了该用户的对称加密算法，公钥、公司名、地址 VPN分类 二层VPN : FR ATM 三层VPN : GRE IPSEC VPN GRE：通用路由封装 ，无安全性保障 MPLS VPN：VPN是在ISP内完成的，安全性较高、有QOS保障 IPSEC VPN：VPN是在C网络中完成，安全性非常高，无QOS保障 IPSEC VPN：IPSEC，对IP数据进行加密或认证 使用IKE协商 ，使用ESP或AH封装保证数据传输的安全性. IPSEC VPN 模式： Transport mode ：传输模式,不会新增加IP头部 Tunnel mode ：隧道模式，增加了一个新的IP头部 IPSEC VPN工作过程分类： Site-to-site VPN ：站点到站点 LAN to LAN Remote-access ：远程访问 IPSEC VPN IKE ： Internet key exchange 互联网密钥交互协议 使用封装协议： ESP AH ESP ： 负载封装安全协议，使用IP封装协议为50，针对data或原始IPV4头部+Data进行加密，针对 ESPherder，payload，ESP，tail 进行认证，认证之后的Hash存放在ESP tail中. AH：认证头部，使用IP封装协议号位51，针对内层IP头部以及Data数据进行认证，不包含加密过程 源认证：HMAC ，密钥化哈希 SPI: 安全关联索引 Seq num：序列号 IV：初始化向量 实施IPSEC VPN 保证路由通信（双方site之间的公有IP地址时是可以互访） 定义感兴趣流量（针对某些流量使用IPSEC 传递） IKE 第一阶段，ISAKMP SA协商 IKE 第二阶段，IPSEC SA协商 将感兴趣流量、ISAKMP IPSEC SA等信息关联至crypto-map，在连接外网的接口上调用 终止IPSEC VPN 部署 保证通信R1(config)#ip route 0.0.0.0 0.0.0.0 12.1.1.2R2(config)#ip route 0.0.0.0 0.0.0.0 12.1.1.1结果 1234R1#ping ping 2.2.2.2 source 1.1.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 2.2.2.2, timeout is 2 seconds:!!!!! 定义感兴趣流量（使用ACL）R1(config)#access-list 100 permit icmp host 1.1.1.1 host 2.2.2.2R2(config)#access-list 100 permit icmp host 2.2.2.2 host 1.1.1.1 定义ISAKMP SA信息 定义ISAKMP 策略（用于轮循）R1(config)#crypto isakmp policy 10 定义对称加密算法R1(config-isakmp)#encryption 3des 定义hash认证算法R1(config-isakmp)#hash md5 选择使用域共享密钥方式产生keyR1(config-isakmp)#authentication pre-share 定义非对称加密算法（为DH-2）R1(config-isakmp)#group 2 定义域共享密钥 key 值R1(config)#crypto isakmp key cisco address 12.1.1.2 定义IPSEC SA（使用ESP或AH方式加密认证）（ipsec）R1(config)#crypto ipsec transform-set ipsec esp-aes esp-sha-hmac 定义crypto map 定义名称R1(config)#crypto map ccie 10 ipsec-isakmp 指定某个对方IP地址生效R1(config-crypto-map)#set peer 12.1.1.2 定义转换集（ipsec）R1(config-crypto-map)#set transform-set ipsec 调用感兴趣流（ACL）R1(config-crypto-map)#match address 100 接口调用R1(config)#int f0/0R1(config-if)#crypto map ccie *Dec 24 15:34:08.483: %CRYPTO-6-ISAKMP_ON_OFF: ISAKMP is ON R2同理ping结果123456R1#ping 2.2.2.2 source 1.1.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 2.2.2.2, timeout is 2 seconds:Packet sent with a source address of 1.1.1.1 .!!!! 结果抓包]]></content>
      <categories>
        <category>CCNP</category>
      </categories>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换安全]]></title>
    <url>%2F2018%2F12%2F22%2F%E4%BA%A4%E6%8D%A2%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 交换安全MAC地址攻击概念：攻击者不断修改自己的MAC地址，交换机进行大量学 习，导致交换机mac地址表缓存溢出，不能再学习其他的Mac地址信息， 此时交换机将工作在hub状态 解决方案：1.静态MAC地址写入静态MAC地址写书：sw1(config)#mac address-table static 000a.000b.000c vlan 1 interface ethernet 2/0查看： sw1#sho mac address-table static结果： Mac Address Table ------------------------------------------- Vlan Mac Address Type Ports ---- ----------- -------- ----- 1 000a.000b.000c STATIC Et2/0 Total Mac Addresses for this criterion: 1 2.基于MAC地址过滤sw1(config)#mac address-table static 00a.00b.00c vlan 1 drop3.端口安全设置接口接收的MAC地址数量以及接收授权Mac地址默认启用了端口安全之后，接收MAC地址数据只有1个，授权学习到的第一个MAC地址. 开启端口安全sw1(config-if)#switchport port-security 设置支持的MAC地址数量（默认为1）sw1(config-if)#switchport port-security maximum 1 指定授权的合法的MAC地址123sw1(config-if)#switchport port-security mac-address ?H.H.H 48 bit mac addresssticky Configure dynamic secure addresses as sticky sticky表示粘滞，把接口学习到的第一个mac地址粘滞成一条命令结果 sw1#sho run int e2/0 Building configuration... Current configuration : 197 bytes ! interface Ethernet0/0 switchport mode access switchport port-security switchport port-security mac-address sticky switchport port-security mac-address sticky 0203.e900.0200 duplex auto end 选择触发端口安全惩罚方式若触发了端口安全： 1.shutdown（默认） 2.protect（保护） 3.restrict（限制） sw1(config-if)#switchport port-security violation ? protect Security violation protect mode restrict Security violation restrict mode shutdown Security violation shutdown mode 默认：由于触发了端口安全，导致接口error-disable （shutdown），不能自动恢复，保护和限制都会丢弃未授权mac地址的数据帧 查看接口授权MAC地址 sw1#sho port-security address Secure Mac Address Table ------------------------------------------------------------------- Vlan Mac Address Type Ports Remaining Age (mins) ---- ----------- ---- ----- ------------- 1 0203.e900.0500 SecureSticky Et2/0 - ------------------------------------------------------------------- Total Addresses in System (excluding one mac per port) : 0 Max Addresses limit in System (excluding one mac per port) : 4096 默认模式由于触发了端口安全，导致接口error-disable （shutdown），不能自动恢复，则有两种启用方式:1.shutdown接口 no shutdown2.开启err-disable针对端口安全导致的自动恢复sw1(config)#errdisable recovery cause psecure-violation设置恢复间隔（默认自动恢复300s）sw1(config)#errdisable recovery interval 30查看（部分） sw1#sho errdisable recovery Recovery Status Timer Status --------------- ------------ psecure-violation Enabled Timer interval: 30 seconds 查看 sw1#sho port-security Secure Port MaxSecureAddr CurrentAddr SecurityViolation Security Action (Count) (Count) (Count) --------------------------------------------------------------------------- Et2/0 1 1 0 Shutdown --------------------------------------------------------------------------- Total Addresses in System (excluding one mac per port) : 0 Max Addresses limit in System (excluding one mac per port) : 4096 VLAN 间攻击概念：默认交换机接口模式为auto或desirable ，主机模拟交换机发 送DTP协商帧，建立trunk链路。 学习交换网络中的某些重要信息，发送 VTP/BPDU等信息干涉交换网络工作 解决方案：将连接用户的接口设置为 access 接口sw1(config-if)#switchport mode access在trunk 链路中针对Native 打标记.sw1(config)#vlan dot1q tag native 私有VLANPrivate VLAN ：私有Primary VLAN ：主VLAN（可以有n个辅助VLAN）Secondary VLAN ：辅助VLAN 辅助VLAN分为两种：1.团体VLAN 2.孤立VLAN主VLAN可以与辅助VLAN通信，辅助VLAN之间不能通信，孤立VLAN之间不能通信，团体VLAN内的用户可以通信主VLAN ： 混杂接口团体VLAN ：团体主机接口孤立VLAN：孤立主机接口配置时团体和孤立VLAN的接口统一为主机接口使用私有VLAN ， VTP模式必须为透明模式。配置设置为透明模式sw1(config)#vtp mode transparent创建两个辅助VLAN501为团体VLAN，502为孤立VLANsw1(config)#vlan 501sw1(config-vlan)#private-vlan communitysw1(config-vlan)#exisw1(config)#vlan 502sw1(config-vlan)#private-vlan isolatedsw1(config-vlan)#exi创建VLAN100为主VLANsw1(config)#vlan 100sw1(config-vlan)#private-vlan primary将VLAN501和502关联到主VLAN100sw1(config-vlan)#private-vlan association 501-502将接口划入主VLAN1.定义接口为混杂接口sw1(config)#int e2/1sw1(config-if)#switchport mode private-vlan promiscuous2.接口划入VLANsw1(config-if)#switchport private-vlan mapping 100 501-502将接口划入辅助VLAN5011.定义接口为主机接口sw1(config)#int range ethernet 2/2-3sw1(config-if-range)#switchport mode private-vlan host2.接口划入VLANsw1(config-if-range)#switchport private-vlan host-association 100 501将接口划入辅助VLAN5021.定义接口为主机接口sw1(config)#int range ethernet 2/4-5sw1(config-if-range)#switchport mode private-vlan host2.接口划入VLANsw1(config-if-range)#switchport private-vlan host-association 100 502查看： sw1#sho vlan private-vlan Primary Secondary Type Ports ------- --------- ----------------- ------------------------------------------ 100 501 community Et2/1, Et2/2, Et2/3 100 502 isolated Et2/1, Et2/4, Et2/5 DHCP 欺骗攻击概念：DHCP 欺骗攻击（spoofing），攻击者模拟为DHCP服务器，下发不正确的IP地址和网关现象： R3(config-if)#do sho ip int b Interface IP-Address OK? Method Status Protocol Ethernet0/0 20.1.1.2 YES DHCP up up 接口重新shutdown no shutdown之后 重新获取地址 R3(config-if)#do sho ip int b Interface IP-Address OK? Method Status Protocol Ethernet0/0 10.1.1.2 YES DHCP up up 解决方案：DHCP snooping 信任接口：接收offer ack（由服务器发送） 转发discover request（由主机发送）非信任接口：接收discover request （由主机发送） 转发 offer ack（由服务器发送） 将连接DHCP server接口设置为信任端口，其他为非信任接口。将交换机设置为路由器信任的中继代理。部署：开启DHCP snoopingSW1(config)#ip dhcp snooping针对某些VLAN开启snoopingSW1(config)#ip dhcp snooping vlan 1设置接口为信任接口SW1(config)#int e2/1SW1(config-if)#ip dhcp snooping trust在DHCP sever上开启针对DHCP中继信息信任R1(config)#ip dhcp relay information trust-all查看 SW1#sho ip dhcp snooping binding MacAddress IpAddress Lease(sec) Type VLAN Interface ------------------ --------------- ---------- ------------- ---- ------------ 000a.0000b.000c 10.1.1.2 86342 dhcp-snooping 1 Ethernet2/1 Total number of bindings: 1 由于二层交换机解析高层（dhcp使用udp协议，应用层）性能较弱，攻击者会向交换机发送高频率的discovery报文，导致交换机瘫痪解决办法：定义非信任接口接收dhcp消息包的频率SW1(config)#int range e2/2-3SW1(config-if-range)#ip dhcp snooping limit rate 2若超过此速率，会导致接口error-disable （shutdown） ARP欺骗攻击概念：主机发送大量IP地址变化的无故ARP，使网段中所有主机学习大量IP地址 的ARP映射都为攻击者，导致网络瘫痪 解决方案：1.静态ARP映射（临时解决方案）2.DAI（Dynamic ARP Intercept 动态ARP截取 ）必须依赖DHCP snooping 中所产生DHCP Snooping binding表.若攻击者的IP地址和DHCP Snooping binding表中mac地址所对应的IP地址不一致，则shutdown该接口部署：全局启用ARP截取SW1(config)#ip arp inspection vlan 1连接网关、server 等设备设置为信任接口SW1(config)#int e2/1SW1(config-if)#ip arp inspection trust]]></content>
      <categories>
        <category>CCNP</category>
      </categories>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spanning Tree 增强]]></title>
    <url>%2F2018%2F12%2F03%2FSpanning-Tree-%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 Spanning Tree 增强portfast 端口加速 针对交换机的access接口，连接的是终端用户例如router、PC、server 等等，这些不需要运行生成树的接口。 接口默认进入listening状态，等待 30s才能进入转发状态. 位置：接入层交换机的access 接口 做完之后节约时间：30s 配置sw1(config)#int range ethernet 2/0-1sw1(config-if-range)#spanning-tree portfast提示： %Warning: portfast should only be enabled on ports connected to a single host. Connecting hubs, concentrators, switches, bridges, etc... to this interface when portfast is enabled, can cause temporary bridging loops. Use with CAUTION %Portfast will be configured in 2 interfaces due to the range command but will only have effect when the interfaces are in a non-trunking mode. 注意：不同型号的交换机命令稍有不同 全局启用：sw1(config)#spanning-tree portfast edge default 在某些接口上关闭portfastsw1(config)#int e0/1sw1(config-if)#spanning-tree portfast disable 在trunk接口启用portfast（默认情况下，接口一旦收到BPDU，portfast 失效）sw1(config)#int e0/1sw1(config-if)#spanning-tree portfast edge trunk uplinkfast 上行链路加速 若上行链路发送故障，阻塞端口进入listening 状态，默认等待30s进 入forwarding 位置：所有的接入层交换机上 节约时间30s 配置首先将sw1，sw2，sw3上的e0/0-3，e1/0-1关闭，然后打开sw1上的e0/0，e0/2，sw2上的e0/0，e1/0，sw3上的e0/2，e1/0则sw1为根网桥，sw1接口全为制定端口，sw2上e0/0为根端口，e1/0为指定端口，sw3上e0/2为根端口，e1/0为阻塞端口结果 sw1 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et0/0 Desg FWD 100 128.1 Shr Et0/2 Desg FWD 100 128.3 Shr sw2 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et0/0 Root FWD 100 128.1 Shr Et1/0 Desg FWD 100 128.33 Shr sw3 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et0/2 Root FWD 100 128.3 Shr Et1/0 Altn BLK 100 128.33 Shr 打开sw3的debugsw3#debug spanning-tree events Spanning Tree event debugging is on 关闭sw3上e0/2，即down掉sw3到sw1的上行链路sw3(config)#int e0/2sw3(config-if)#shu 结果：可以看到e1/0端口立即进入listening状态，随即15秒后进入learning，再15秒进入forwarding，即e1/0阻塞端口成为根端口转发数据，整个过程用了30s sw3(config-if)# *Nov 24 22:16:35.014: STP: VLAN0001 new root port Et1/0, cost 200 *Nov 24 22:16:35.014: STP: VLAN0001 Et1/0 -&gt; listening *Nov 24 22:16:35.014: STP[1]: Generating TC trap for port Ethernet0/2 sw3(config-if)# *Nov 24 22:16:37.018: %LINK-5-CHANGED: Interface Ethernet0/2, changed state to administratively down sw3(config-if)# *Nov 24 22:16:37.018: STP: VLAN0001 sent Topology Change Notice on Et1/0 *Nov 24 22:16:38.026: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/2, changed state to down sw3(config-if)# *Nov 24 22:16:50.018: STP: VLAN0001 Et1/0 -&gt; learning sw3(config-if)# *Nov 24 22:17:05.018: STP[1]: Generating TC trap for port Ethernet1/0 *Nov 24 22:17:05.018: STP: VLAN0001 sent Topology Change Notice on Et1/0 *Nov 24 22:17:05.018: STP: VLAN0001 Et1/0 -&gt; forwarding 打开e0/2端口然后做uplinkfastsw3(config)#spanning-tree uplinkfast 变化：意思他要离根网桥远一点，一般最底层的接入层交换机才做 显示 Uplinkfast enabled 优先级变为 priority 49152 32768+4*4096=49152 cost值增加3000 再次关闭e0/2端口结果 *Nov 24 23:04:45.790: %SPANTREE_FAST-7-PORT_FWD_UPLINK: VLAN0001 Ethernet1/0 moved to Forwarding (UplinkFast). 表示e1/0口直接成为根端口转发数据 Interface Role Sts Cost Prio.Nbr Type ------------------- ---- --- --------- -------- -------------------------------- Et1/0 Root FWD 3100 128.33 Shr 全局模式Spanning tree uplinkfast rata-limit 100 （单位数据包每秒）开始sw3上的e1/0接口是阻塞的，通过e0/2接口学习mac地址转发数据，若e0/2 down掉，则e1/0成为根端口转发数据，此时sw2上则需要学习sw3上大量的mac地址，为了做好切换过程，做了全局uplinkfast后，在e0/2未down之前会通过e1/0阻塞端口向上发送伪包，为了让sw2学习sw3上的mac地址，则若e0/2 down掉，e1/0成为根端口后可以直接转发数据。 backbonefast 骨干加速 若骨干链路发生故障，下行链路经过50s进入forwarding状态； 启用backbonefast特性，若收到次级BPDU，通过根端口向根网桥发送 RIQ查询（询问优质根是否正常），若正常由根网桥返回RIQ应答，描 述根正常，则blocking接口进入listening状态，经过30s进入forwarding. 部署位置：所有交换机 节约时间：20s 启用backbonefast特性重新打开sw3的e0/2接口，则e0/2重新成为根端口，e1/0为阻塞端口若down掉sw1连接sw2的骨干链路（关闭sw2的e0/0），则sw3的e1/0接口成为指定端口，sw2的e1/0成为根端口，这个过程中sw3的e1/0接口成为指定端口需要经过50s sw3(config-if)# *Nov 24 23:35:02.798: STP: VLAN0001 heard root 28673-0203.e900.0200 on Et1/0 sw3(config-if)# *Nov 24 23:35:03.966: STP: VLAN0001 Et1/0 -&gt; listening *Nov 24 23:35:04.798: STP: VLAN0001 heard root 28673-0203.e900.0200 on Et1/0 *Nov 24 23:35:04.798: STP: VLAN0001 Topology Change rcvd on Et1/0 *Nov 24 23:35:04.798: STP: VLAN0001 sent Topology Change Notice on Et0/2 sw3(config-if)# *Nov 24 23:35:18.974: STP: VLAN0001 Et1/0 -&gt; learning sw3(config-if)# *Nov 24 23:35:33.974: STP[1]: Generating TC trap for port Ethernet1/0 *Nov 24 23:35:33.974: STP: VLAN0001 sent Topology Change Notice on Et0/2 *Nov 24 23:35:33.974: STP: VLAN0001 Et1/0 -&gt; forwarding *Nov 24 23:35:33.974: stp_state_change_completed: Et1/0. new state = FWD 详解：骨干链路断开后，sw2不能收到sw1的BPDU，所以sw2就以为自己是根网桥，则sw2会向sw3发送BPDU（此BPDU与之前向sw3发送的不一样，之前发送的rid是sw1，bid是sw2自己，现在发送的rid和bid都是sw2自己），此时sw3通过sw1收到的BPDU，rid要优于sw2发送的（称sw2的为次级BPDU），故sw3会忽略sw2发送的BPDU，但sw3的阻塞端口e1/0会一直监听sw2发来的BPDU，之前一直收到的是来自于根网桥的BPDU，现在不能收到来自于根网桥的BPDU了，超时时间20s，则sw3的e1/0端口会进入listening状态，告诉sw2根网桥还活着（向sw2发送优质BPDU），直到进入forwarding，整个过程需要50s backbonefast建议在所有交换机都做骨干链路断开之后，sw2会向sw3发送次级BPDU，sw3会忽略，做了backbonefast后，收到次级BPDU后，sw3会主动向根网桥发送根链路查询请求报文（RLQ request） ，根网桥会回复根链路查询响应报文（RLQ response），sw3知道sw2收不到根网桥发送的BPDU，以为自己是根网桥了，所以sw3的e1/0接口直接进入listening状态，告诉sw2根网桥还活着（向sw2发送优质BPDU），直到进入forwarding，整个过程需要30s，节约了20s。重新打开sw2的e0/0端口配置sw1(config)#spanning-tree backbonefastsw2(config)#spanning-tree backbonefastsw3(config)#spanning-tree backbonefast关闭sw2的e0/0端口结果 sw3(config)# *Nov 25 00:07:22.998: STP: VLAN0001 heard root 28673-0203.e900.0200 on Et1/0 *Nov 25 00:07:22.998: STP: VLAN0001 Et1/0 -&gt; listening 可知sw3的e1/0端口立即进入listening状态。 根端口：root port RP指定端口：DP阻塞端口：NDP]]></content>
      <categories>
        <category>CCNP</category>
      </categories>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复习重点]]></title>
    <url>%2F2018%2F12%2F03%2FC-%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 C++重点 函数重载必须有不同的形参列表 析构函数可以是虚函数 具有纯虚函数的类不能创建类对象 静态数据成员是类的所有对象共享的数据 将一组对象的共同特征抽象出形成类 friend void B::fun(); //B的成员函数fun()说明为A的友元函数 如果一个引用不是用作函数参数或返回值，则在说明该引用时必须进行 初始化 const double pi = 3.141592653589793 ; int operator++(int x); // ++运算符重载 动态联编通过基类指针或引用调用虚函数完成 构造函数访问权限是公有的 基类对象的地址不能赋给派生类 创建对象时 test(2); 表示创建一个对象并赋值2 test[2]; 表示创建两个对象，并且值为默认值 main函数执行完毕之后才执行析构函数，每个对象析构一次 创建对象时，类a被调用一次，执行类a里的函数时，类a又被调用一次 c继承b，c类内对a赋值，创建c类对象时 先调用类b，再调用类a，最后调用c类本身。 在函数模板的参数中，用class修饰的参数称为虚拟类型参数 以面向对象方法构造的系统，其基本单位是对象 对象是类的一个实列 对象将其大部分细节隐藏起来，这种机制称为封装 复杂对象可以由简单对象构成，称为聚合 C++支持编译时的多态性和运行时的多态性 C++中，编译时的多态性是通过重载实现，运行时的多态性通过虚函数实现 三个阶段：分析，设计，实现 若在类的定义体中给出了一个成员函数的完整定义，则该函数属于内联函数 把一个类的定义体和所有成员函数的定义体所构成的程序范围叫做该类的作用域 对类中对象成员的初始化是通过在构造函数中给出的初始化表实现的，也可以通过构造函数中的函数体实现 对类中对象成员和常量成员和引用成员的初始化是通过构造函数给出的初始化表实现的 AB为一个类， AB(AB&amp; x); 为类AB的拷贝构造函数 重载运算符时，该运算符的优先级，结合性，操作符的个数不允许改变，不能创建没有的运算符 单目运算符作为类的成员函数重载时有0个参数，独立函数重载时有1个参数。双目运算符作为类的成员函数重载时有1个参数，独立函数重载时有2个参数。赋值运算符不能被派生类继承 虚基类是为了消除二义性 在每个成员函数中，隐含的第一个参数的参数名为this 隐含的第一个参数类型为 类名* 保证一个公共的基类在派生类中只产生一个基类子对象，则必须都以虚基类的方式直接继承它。 B类继承A类，用B类创建对象后，先析构B类，在析构A类 用户可以重新定义标准库函数，若如此，该函数将失去原有含义 引用调用是 形参是引用，实参是变量 函数调用不可以作为一个函数的形参 成员函数重载是为了使用方便，提高可读性和灵活性 void *为无类型指针，能够指向不论什么数据类型，可以用随意数据类型的指针对void指针赋值 面向对象方法的多态性是指针对一消息，不同的对象可以以适合自身的方式加以响应 OOA：面向对象分析（analysis） OOD：面向对象设计（design） 类中定义的成员默认为private访问属性，结构中定义的成员默认为public访问属性 一个类的静态数据成员所表示属性只是类的属性 静态成员函数只允许操作静态成员变量，不允许操作非静态成员变量 静态数据成员的初始化是在全局区中进行的 类A是类B的友元类，类A的所有成员函数都可以访问类B的所有成员。 一个类的友元不是该类的成员，但与该类的关系密切，所以他没有this指针，也就没有默认操作的对象 a++中的++是作为普通函数重载的运算符，则调用格式可以是operator++(a,1)++a中的++是作为成员函数重载的运算符，则调用格式可以是a.operator++()]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spanning Tree]]></title>
    <url>%2F2018%2F12%2F02%2FSpanning-tree%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 Spanning Tree 生成树目的：交换机之间存在冗余（备份）路径，以及交换机的泛洪机制，导致交换机之间产生 二层交换环路。 造成影响：1.广播风暴（数据在两个或多个交换机之间大量重复传递）2.MAC地址表不稳定 （交换机会将某个主机的mac地址重复删除和学习）3.数据帧的重复拷贝（由于ARP会泛洪和数据的重复传递，导致A主机发送的ARP会被交换机重复发送到B主机） 解决方案：逻辑性阻塞某个接口. 在交换机之间，通过发送比较信息，选择在环路之间应该被阻塞的接口. 生成树类型： 公有生成树：STP（又称为802.1D 标准生成树）RSTP（802.1W 快速生成树）MST（802.1S 多生成树） 私有生成树：PVST（基于VLAN的标准生成树，每一VLAN都有自己的一套生成树）PVRST+（基于VLAN的快速生成树） 发送比较信息BPDU—网桥协议数据单元配置BPDU：config-BPDU拓扑变更BPDU：TCN-BPDU Protocol ID：协议号，代表我是一个BPDU报文 Version：表示是哪一种BPDU（802.1D或者802.1W等） Message Type：表示是配置BPDU还是拓扑变更BPDU Flags：802.1D中描述是拓扑变更BPDU还是拓扑变更BPDU确认，占2Bit。802.1W和802.1S中，用于整个生成树的选举，占6Bit。 Root ID：根标识符 ，在一棵生成树中表示唯一根.使用最优质的BID表示，即根交换机的RID=BID。 Cost Of Path：也称为CoP值，路径开销，描述了本接口到达根的路径开销值之和，数值越小越优10G—–21G——–4100M—–1910M—–100默认根网桥上所有接口的COP值为0，经过不同的链路增加对应的cost Bridge ID ：网桥标识符，用于表示该交换机或网桥在交换网络中的唯一性构成：BID 优先级 + mac地址注意：PVST、PVRSTP+ 的构成 ：BID优先级+VLAN ID+mac地址MST 的构成 ：BID优先级+ instance ID + mac地址 BID优先级：默认值为32768，数值范围0-65535（BID优先级数值必须为4096的倍数， 范围也可称为0-61440）,再使用BID优先级时，数值越小越优. Mac 地址：本交换机上背板地址池中最小的MAC地址，mac地址越小越优 Port ID ：端口标识符，用于表示本交换机上接口的唯一性标识构成： PID优先级+port number PID优先级：默认为128，数值范围0-255（PID优先级必须为16的倍数，所有范围 0-240）,数值越小越优 Port number：端口号，表示了本交换机该接口的唯一性，一般为接口的端口号标 识，数值越小越优. Message age ：消息时间，也称消息的老化时间，实际上等于MAC地址老化时间， 默认300s，即300s不发任何数据就删掉此mac地址，在启用portfast等特性时变为15s Max age ：最大等待时间，默认20s，hello数据包的超时时间以及从blocking进入 listening 状态等待时间 Hellotime ：默认2s，配置BPDU的发送间隔 Forward delay ：转发延时，默认15s ，在生成树中状态切换间隔Listening进入learning进入forwarding 时间隔 交换网络中交换机的角色以及端口状态切换交换机角色：分为根网桥和非根网桥端口角色：根端口、指定端口、非指定端口（阻塞端口）端口状态切换： Blocking ：阻塞状态，不能发送BPDU，接收BPDU，不能发送和接收数据，被动等待 20s进入下一状态 Listening ：监听状态，可以发送和接收BPDU，不能发送和接收数据，进行STP选举， 被动等待一个 forward delay 15s进入下一状态 Learning ：学习状态，可以发送和接收BPDU，不能发送和接收数据，可以学习BPDU 中的源MAC地址（MAC地 址学习状态），被动等待一个forward delay 15s进入下一 状态，生成树的选举在此过程中完成。 Forwarding ：转发状态，可以发送、接收BPDU和数据，mac地址学习和生成树接口 状态切换完成 生成树选举选举顺序：根网桥-&gt;根端口-&gt;指定端口-&gt;非指定端口(阻塞端口)根网桥选举：具有最优BID的交换机为根网桥 根端口：用于接收来自根的BPDU信息，只能存在于非跟网桥之上，并且一个交换机 只能存在一个. 根端口选举1.最小COP值2.发送方最小的BID3.发送方的PID 指定端口：用于发送或转发BPDU信息，存在于每条链路中，一条只能存在一个指定 端口，根网桥的所有接口全为指定端口 指定端口选举1.接口所属交换机上根端口到达根网桥的COP值2.本交换机BID3.本地的PID阻塞端口逻辑上打破接口. 选举详细过程根网桥选举 这里假设sw1 BID优先级最高（bid优先级以此类推），故sw1为根网桥根端口选举 SW1：无根端口 SW2：1.最小cop（接口1和2）相同2.发送方都为根网桥，bid相同3.根网桥接口5的pid小，故选出根端口为接口1 SW3：1.最小cop（接口1和2）相同2.发送方都为根网桥，bid相同3.根网桥接口1的pid小，故选出根端口为接口1 SW4：1.最小cop（接口1和2）相同2.发送方都为根网桥，bid相同3.根网桥接口3的pid小，故选出根端口为接口1 SW5：1.最小cop（接口1和2）相同2.发送方sw3的bid小于sw4的bid，故选出根端口为接口1 SW6：1.最小cop（接口1和2）相同2.发送方sw3的bid小于sw4的bid，故选出根端口为接口1 根端口选举结果如图 指定端口选举 SW1：所有接口都为指定端口 SW2：接口2一定为阻塞端口1.接口3和4与sw2相比， cop相同，接口5与6和sw4相比，cop相同2.本交换机BID优于sw3和sw4，故接口3，4，5，6为指定端口 SW3：sw5和sw6有唯一的根端口，故接口7和8一定为指定端口，接口2，3，4一定为阻塞端口1.接口5和6与sw4相比cop相同2.本交换机BID优于sw4，故接口5和6为指定端口 SW4：接口2，3，4一定为阻塞端口1.接口7与sw5相比，cop小于sw5，故接口7为指定端口接口8与sw6相比，cop小于sw6，故接口8为指定端口 SW5：接口2为阻塞端口 SW6：接口2为阻塞端口 指定端口选举第三条的特殊情况假设sw1和sw2的cop相同，sw2的bid优，但sw2的接口1和2不能同时成为指定端口，否则会出环，所以比第三条接口pid，由于sw2的接口1的pid小于接口2的pid，故接口1成为指定端口生成树拓扑结构变化由发生改变的交换机的根端口向根网桥发送拓扑变更BPDU，根网桥收到后以自己为根重新收敛，之后在向之前发送拓扑变更BPDU的根端口发送拓扑变更BPDU确认 生成树的控制 根网桥的控制设置BID优先级，默认为32768，修改sw2的bid为32768-4096=28672sw2(config)#spanning-tree vlan 1 priority 28672This bridge is the root设置主根和备份根，设置sw1为主根，sw2为备份根sw1(config)#spanning-tree vlan 1 root primarysw2(config)#spanning-tree vlan 1 root secondary主根的优先级变为32768-2*4096=24576Bridge ID Priority 24577 (priority 24576 sys-id-ext 1)备份根的优先级变为32768-4096=28672Bridge ID Priority 28673 (priority 28672 sys-id-ext 1) 控制根端口的位置修改链路cost值：修改sw2的cost为120sw2(config-if)#spanning-tree vlan 1 cost 120修改前Et0/0 Root FWD 100 128.1 ShrEt0/1 Altn BLK 100 128.2 Shr修改后Et0/0 Altn BLK 120 128.1 ShrEt0/1 Root LIS 100 128.2 Shr修改发送方BID：与上述修改根网桥之修改BID优先级方法一致修改发送方PID：修改sw1的e0/2接口pid为192sw1(config-if)#spanning-tree vlan 1 port-priority 192修改之后sw1Et0/2 Desg FWD 100 192.3 Shr修改之前sw3Et0/2 Root FWD 100 128.3 ShrEt0/3 Altn BLK 100 128.4 Shr修改之后sw3Et0/2 Altn BLK 100 128.3 ShrEt0/3 Root LIS 100 128.4 Shr 802.1D生成树优缺点优点：树少、简单、缺点：生成树收敛速度慢（默认共计收敛时间50s），基于计时器收敛、不能进行负 载分担 PVST优缺点优点：简单、支持负载分担缺点：生成树收敛速度慢，生成树数量较多. 解决办法：1.使用spanning tree 的增强特性 portfast、backbonefast 、uplinkfast2.使用RSTP或MST]]></content>
      <categories>
        <category>CCNP</category>
      </categories>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信透明头像]]></title>
    <url>%2F2017%2F12%2F07%2F%E5%BE%AE%E4%BF%A1%E9%80%8F%E6%98%8E%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 先来一张效果图 教程开始素材的准备和PhotoShop软件这里我以滑稽表情为例 用PS打开滑稽表情 按住Shift+Ctrl+N新建图层 抠图 抠图完成后按Ctrl+X 然后删除这个图层 按Ctrl+V粘贴到第二部新建的图层中然后选中这个图层 按Ctrl+T进行缩放 缩放成如图所示的大小 保存为png格式 复制到手机上（复制原文件）在手机微信上更换图像这里需要注意的是 要把图像缩放到合适的大小手动滑稽~…~]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为MIUI添加人脸解锁]]></title>
    <url>%2F2017%2F12%2F02%2F%E4%B8%BAMIUI%E6%B7%BB%E5%8A%A0%E4%BA%BA%E8%84%B8%E8%A7%A3%E9%94%81%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 玩腻了指纹解锁，试试看人脸识别吧，FaceID For MIUI9_MI5解Bootloader锁解Bootloader锁教程:点这里 刷第三方Recovery小米5专用RecoveryBY~XM大佬的rec本人一直用的这个rec 支持OTA增量更新 进入rec法一：开机按电源键+音量键上 直到mi标出现放开电源键法二：系统更新界面-右上角三个小圆点-重启到恢复模式（Recovery） 刷入卡刷包请注意此卡刷包只适用于官方稳定版或开发版FaceID For MIUI9_Mi5.zip密码：6666 重启大功告成不刷第三方rec的方法还是解Bootloader锁解Bootloader锁教程:点这里 下载资源下载软件里边有所有的资源小米五人脸解锁提取+工具.zip密码：6666 安装两个APPRE文件管理器，syslock（用来解system锁） 获取root权限并赋予权限1.开发版直接在安全中心开启root权限2.给这两个APP赋予root权限3.使用syslock解锁system（需要重启） 至此获取了完整的root权限 替换文件1.用《需要替换的app》中的两个apk文件替换 /system/priv-app/settings 和 /system/priv-app/MiuiKeygard 中的两个 App.2.用《需要替换的文件》中的五个文件替换 system/lib64 目录下的五个 so 文件（直接复制进去） Reboot 大功告成！小米五，红米note4.MIX.5s.5sp.部分6.部分红米.5x暂时都可以使用，理论支持miui9所有稳定版，开发板，体验版。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义QQ动态图像的教程]]></title>
    <url>%2F2017%2F11%2F10%2FQQ%E5%8A%A8%E6%80%81%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[不是不做，时候未到。 自定义QQ动态图像可以先看一下我的QQ头像。点击加我为好友其实很简单，就是一个替换文件的操作。 把要设置的视频【MP4格式，10秒之内，文件尽量不要太大】粘贴到（DCIM）里面的（Camera）文件夹里，切记不要退出。 切换到QQ，点开头像拍摄动态头像，这一点要记住拍完视频不要点完成。 切换到文件管理，你会发现这个文件夹里多了一个视频，你把这个多出来的视频文件名复制一下，并且删除这个视频。 然后找到你刚才剪切粘贴的那个视频，把文件名字替换了，切换QQ点完成就可以了。是不是很简单呢，如果没明白的话，去我的QQ空间有视屏教程。tips：进空间使劲往下拉。 使用Ctrl+D收藏本站 不是不做，时候未到。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
